library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library neorv32;
use neorv32.neorv32_package.all;

entity top_neorv32 is
  port (
    clk       : in  std_logic; 
    rst_n     : in  std_logic; 
    uart_txd  : out std_logic; 
    uart_rxd  : in  std_logic; 
    led_out   : out std_logic  
  );
end entity;

architecture rtl of top_neorv32 is

  -- Sinais do Barramento
  signal wb_adr       : std_ulogic_vector(31 downto 0);
  signal wb_dat_read  : std_ulogic_vector(31 downto 0);
  signal wb_dat_write : std_ulogic_vector(31 downto 0);
  signal wb_we        : std_ulogic;
  signal wb_sel       : std_ulogic_vector(3 downto 0);
  signal wb_stb       : std_ulogic;
  signal wb_cyc       : std_ulogic;
  signal wb_ack       : std_ulogic;

  -- NOVO: Sinal interno para "espelhar" o estado do LED
  signal led_reg      : std_logic;

begin

  -- Atribuição contínua: o pino físico sempre recebe o valor do registrador interno
  led_out <= led_reg;

  -- 1. Instância do Processador NEORV32
  neorv32_top_inst: entity work.neorv32_top
  generic map (
    CLOCK_FREQUENCY   => 50000000,
    BOOT_MODE_SELECT  => 0,
    IMEM_EN           => true,
    IMEM_SIZE         => 16384,
    DMEM_EN           => true,
    DMEM_SIZE         => 8192,
    IO_UART0_EN       => true,
    XBUS_EN           => true
  )
  port map (
    clk_i          => std_ulogic(clk),
    rstn_i         => std_ulogic(rst_n),
    uart0_txd_o    => uart_txd,
    uart0_rxd_i    => std_ulogic(uart_rxd),
    xbus_adr_o     => wb_adr,
    xbus_dat_o     => wb_dat_write,
    xbus_dat_i     => wb_dat_read,
    xbus_we_o      => wb_we,
    xbus_sel_o     => wb_sel,
    xbus_stb_o     => wb_stb,
    xbus_cyc_o     => wb_cyc,
    xbus_ack_i     => wb_ack,
    xbus_err_i     => '0'
  );

  -- 2. Periférico de LED
  process(clk, rst_n)
  begin
    if rst_n = '0' then
      wb_ack      <= '0';
      led_reg     <= '0'; -- Reset do sinal interno
      wb_dat_read <= (others => '0');
    elsif rising_edge(clk) then
      wb_ack <= '0';
      
      if (wb_cyc = '1' and wb_stb = '1') then
        wb_ack <= '1';
        
        if wb_we = '1' then
            if wb_adr(7 downto 0) = x"00" then
              -- Alteramos o registrador interno
              led_reg <= std_logic(wb_dat_write(0)); 
            end if;
        end if;
        
        -- Agora lemos o registrador interno (led_reg), o que é permitido!
        wb_dat_read(0) <= std_ulogic(led_reg);
        wb_dat_read(31 downto 1) <= (others => '0');
      end if;
    end if;
  end process;

end architecture;